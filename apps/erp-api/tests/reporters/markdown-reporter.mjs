/**
 * Custom Markdown Reporter for Vitest
 * Generates markdown test reports in docs/test-report.md
 */

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

export default class MarkdownReporter {
  onInit(ctx) {
    this.ctx = ctx;
    this.start = Date.now();
  }

  async onFinished(files, errors) {
    const duration = Date.now() - this.start;

    let totalTests = 0;
    let passedTests = 0;
    let failedTests = 0;
    let skippedTests = 0;

    const results = [];

    files?.forEach((file) => {
      file.tasks?.forEach((suite) => {
        this.processSuite(suite, results);
      });
    });

    // Count totals
    results.forEach((result) => {
      totalTests++;
      if (result.status === 'passed') passedTests++;
      if (result.status === 'failed') failedTests++;
      if (result.status === 'skipped') skippedTests++;
    });

    // Generate markdown report
    const markdown = this.generateMarkdown({
      totalTests,
      passedTests,
      failedTests,
      skippedTests,
      duration,
      results,
      errors,
    });

    // Write to docs/test-report.md
    const docsDir = path.join(process.cwd(), 'docs');
    if (!fs.existsSync(docsDir)) {
      fs.mkdirSync(docsDir, { recursive: true });
    }

    const reportPath = path.join(docsDir, 'test-report.md');
    fs.writeFileSync(reportPath, markdown, 'utf-8');

    // Also write detailed JSON report
    const jsonReport = {
      summary: {
        total: totalTests,
        passed: passedTests,
        failed: failedTests,
        skipped: skippedTests,
        duration,
        timestamp: new Date().toISOString(),
      },
      results,
      errors: errors || [],
    };

    const jsonPath = path.join(docsDir, 'test-report-detailed.json');
    fs.writeFileSync(jsonPath, JSON.stringify(jsonReport, null, 2), 'utf-8');
  }

  processSuite(suite, results, parentName = '') {
    const suiteName = parentName ? `${parentName} > ${suite.name}` : suite.name;

    suite.tasks?.forEach((task) => {
      if (task.type === 'suite') {
        this.processSuite(task, results, suiteName);
      } else if (task.type === 'test') {
        results.push({
          name: `${suiteName} > ${task.name}`,
          status: task.result?.state || 'skipped',
          duration: task.result?.duration || 0,
          error: task.result?.errors?.[0]?.message || null,
        });
      }
    });
  }

  generateMarkdown(data) {
    const { totalTests, passedTests, failedTests, skippedTests, duration, results, errors } = data;

    const passRate = totalTests > 0 ? ((passedTests / totalTests) * 100).toFixed(1) : 0;
    const timestamp = new Date().toLocaleString();

    let md = `# Integration Test Report\n\n`;
    md += `**Generated**: ${timestamp}\n\n`;
    md += `## Summary\n\n`;
    md += `| Metric | Count |\n`;
    md += `|--------|-------|\n`;
    md += `| **Total Tests** | ${totalTests} |\n`;
    md += `| **Passed** | ✅ ${passedTests} |\n`;
    md += `| **Failed** | ❌ ${failedTests} |\n`;
    md += `| **Skipped** | ⏭️ ${skippedTests} |\n`;
    md += `| **Pass Rate** | ${passRate}% |\n`;
    md += `| **Duration** | ${(duration / 1000).toFixed(2)}s |\n\n`;

    if (failedTests > 0) {
      md += `## ❌ Failed Tests\n\n`;
      results
        .filter((r) => r.status === 'failed')
        .forEach((result) => {
          md += `### ${result.name}\n`;
          md += `**Duration**: ${result.duration}ms\n\n`;
          if (result.error) {
            md += `\`\`\`\n${result.error}\n\`\`\`\n\n`;
          }
        });
    }

    if (passedTests > 0) {
      md += `## ✅ Passed Tests\n\n`;
      results
        .filter((r) => r.status === 'passed')
        .forEach((result) => {
          md += `- ${result.name} (${result.duration}ms)\n`;
        });
      md += `\n`;
    }

    if (skippedTests > 0) {
      md += `## ⏭️ Skipped Tests\n\n`;
      results
        .filter((r) => r.status === 'skipped')
        .forEach((result) => {
          md += `- ${result.name}\n`;
        });
      md += `\n`;
    }

    if (errors && errors.length > 0) {
      md += `## ⚠️ Errors\n\n`;
      errors.forEach((error) => {
        md += `\`\`\`\n${error}\n\`\`\`\n\n`;
      });
    }

    md += `---\n\n`;
    md += `*Report generated by Vitest Markdown Reporter*\n`;

    return md;
  }
}
